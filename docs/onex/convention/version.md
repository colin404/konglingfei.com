---
title: 版本号规范
shortTitle: 版本号规范
date: 2022-03-01
icon: banbenhao
sticky: true
star: true
order: 6
isOriginal: true
category:
  - OneX
tag:
  - OneX
---

在做 Go 项目开发时，我建议你把所有组件都加入版本机制。原因主要有两个：一是通过版本号，我们可以很明确地知道组件是哪个版本，从而定位到该组件的功能和代码，方便我们定位问题。二是发布组件时携带版本号，可以让使用者知道目前的项目进度，以及使用版本和上一个版本的功能差别等。

目前业界主流的版本规范是语义化版本规范，也是OneX 系统采用的版本规范。那什么是语义化版本规范呢？
### **什么是语义化版本规范（SemVer）？**
语义化版本规范（SemVer，Semantic Versioning）是 GitHub 起草的一个具有指导意义的、统一的版本号表示规范。它规定了版本号的表示、增加和比较方式，以及不同版本号代表的含义。

在这套规范下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。语义化版本格式为：主版本号.次版本号.修订号（X.Y.Z），其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。

版本号可按以下规则递增：

- 主版本号（MAJOR）：当做了不兼容的 API 修改。
- 次版本号（MINOR）：当做了向下兼容的功能性新增及修改。这里有个不成文的约定需要你注意，偶数为稳定版本，奇数为开发版本。
- 修订号（PATCH）：当做了向下兼容的问题修正。

例如，v1.2.3 是一个语义化版本号，版本号中每个数字的具体含义见下图： 
![](https://cdn.nlark.com/yuque/0/2024/png/43447143/1713265935720-bcff0506-baa2-4f86-b4c2-2f65ca6d5f1c.png#averageHue=%23fafaf9&clientId=ua00a7100-1e29-4&from=paste&id=u543fd89c&originHeight=208&originWidth=356&originalType=url&ratio=1.75&rotation=0&showTitle=false&status=done&style=none&taskId=u30b3df7f-9b14-489b-87d9-57c9c66a349&title=)

你可能还看过这么一种版本号：v1.2.3-alpha。这其实是把先行版本号（Pre-release）和版本编译元数据，作为延伸加到了主版本号.次版本号.修订号的后面，格式为 X.Y.Z[-先行版本号][+版本编译元数据]，如下图所示：
![](https://cdn.nlark.com/yuque/0/2024/png/43447143/1713265935599-c24facce-238d-40d9-bba7-076112656000.png#averageHue=%23f1f1f1&clientId=ua00a7100-1e29-4&from=paste&id=ucb5ee6b4&originHeight=744&originWidth=1841&originalType=url&ratio=1.75&rotation=0&showTitle=false&status=done&style=none&taskId=uedca9d00-fbd9-4b03-8b67-559db1d1cd6&title=)

我们来分别看下先行版本号和版本编译元数据是什么意思。

先行版本号意味着，该版本不稳定，可能存在兼容性问题，格式为：X.Y.Z-[一连串以句点分隔的标识符] ，比如下面这几个例子：
```
1.0.0-alpha
1.0.0-alpha.1
1.0.0-0.3.7
1.0.0-x.7.z.92
```

编译版本号，一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制。下面是一些编译版本号的示例：
```
1.0.0-alpha+001
1.0.0+20130313144700
1.0.0-beta+exp.sha.5114f85
```

注意，**先行版本号和编译版本号只能是字母、数字，且不可以有空格**。
### **语义化版本控制规范**
语义化版本控制规范比较多，这里我给你介绍几个比较重要的。如果你需要了解更详细的规范，可以参考 [这个链接](https://semver.org/lang/zh-CN/) 的内容。

- 标记版本号的软件发行后，禁止改变该版本软件的内容，任何修改都必须以新版本发行。
- 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变，这样的公共 API 不应该被视为稳定版。1.0.0 的版本号被界定为第一个稳定版本，之后的所有版本号更新都基于该版本进行修改。
- 修订号 Z（x.y.Z | x > 0）必须在只做了向下兼容的修正时才递增，这里的修正其实就是 Bug 修复。
- 次版本号 Y（x.Y.z | x > 0）必须在有向下兼容的新功能出现时递增，在任何公共 API 的功能被标记为弃用时也必须递增，当有改进时也可以递增。其中可以包括修订级别的改变。每当次版本号递增时，修订号必须归零。
- 主版本号 X（X.y.z | X > 0）必须在有任何不兼容的修改被加入公共 API 时递增。其中可以包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须归零。
### **如何确定版本号？**
说了这么多，我们到底该如何确定版本号呢？

这里我给你总结了这么几个经验。
第一，在实际开发的时候，我建议你使用 0.1.0 作为第一个开发版本号，并在后续的每次发行时递增次版本号。
第二，当我们的版本是一个稳定的版本，并且第一次对外发布时，版本号可以定为 1.0.0。
第三，当我们严格按照 Angular commit message 规范提交代码时，版本号可以这么来确定：

- fix 类型的 commit 可以将修订号+1。
- feat 类型的 commit 可以将次版本号+1。
- 带有 BREAKING CHANGE 的 commit 可以将主版本号+1。 
